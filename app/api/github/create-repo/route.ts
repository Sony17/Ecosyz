import { NextRequest, NextResponse } from 'next/server';
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import { Octokit } from '@octokit/rest';

export async function POST(request: NextRequest) {
  try {
    const { projectId, name, description, files } = await request.json();

    // Get authenticated user
    const supabase = createClientComponentClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Get user's GitHub token from their profile
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('github_token')
      .eq('user_id', user.id)
      .single();

    if (!profile?.github_token) {
      return NextResponse.json(
        { error: 'GitHub token not found. Please connect your GitHub account first.' },
        { status: 400 }
      );
    }

    // Initialize Octokit with user's token
    const octokit = new Octokit({
      auth: profile.github_token,
    });

    // Get user's GitHub username
    const { data: githubUser } = await octokit.rest.users.getAuthenticated();
    const username = githubUser.login;

    // Create repository name (sanitized)
    const repoName = name.toLowerCase()
      .replace(/[^a-z0-9-_]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');

    // Create the repository
    const { data: repo } = await octokit.rest.repos.createForAuthenticatedUser({
      name: repoName,
      description: description || `AI-generated ${name} project`,
      private: false,
      auto_init: false,
    });

    // Create all files in the repository
    const fileUploads = Object.entries(files).map(async ([filePath, content]) => {
      return octokit.rest.repos.createOrUpdateFileContents({
        owner: username,
        repo: repoName,
        path: filePath,
        message: `Add ${filePath}`,
        content: Buffer.from(content as string).toString('base64'),
      });
    });

    // Add a README if not present
    if (!files['README.md']) {
      const readmeContent = `# ${name}

${description}

## About This Project

This project was generated using Ecosyz AI Code Generator, an intelligent system that transforms research papers, datasets, and code repositories into working web applications.

## Framework

- **Framework**: Auto-detected from project structure
- **Generated**: ${new Date().toISOString()}
- **Project ID**: ${projectId}

## Getting Started

1. **Install Dependencies**
   \`\`\`bash
   npm install
   \`\`\`

2. **Run Development Server**
   \`\`\`bash
   npm run dev
   \`\`\`

3. **Open in Browser**
   Navigate to [http://localhost:3000](http://localhost:3000)

## Features

- ‚ö° AI-generated codebase
- üé® Modern UI with Tailwind CSS
- üì± Responsive design
- üöÄ Production-ready structure
- üîß Best practices implementation

## Deployment

This project is ready to deploy on:

- **Vercel**: \`npx vercel\`
- **Netlify**: Connect your GitHub repository
- **GitHub Pages**: Enable in repository settings
- **AWS Amplify**: Connect your repository

## Support

- **Documentation**: [Ecosyz Docs](https://docs.ecosyz.com)
- **Community**: [Discord](https://discord.gg/ecosyz)
- **Issues**: Create an issue in this repository

---

**Powered by** [Ecosyz AI Code Generator](https://ecosyz.com) üöÄ
`;

      fileUploads.push(
        octokit.rest.repos.createOrUpdateFileContents({
          owner: username,
          repo: repoName,
          path: 'README.md',
          message: 'Add AI-generated README',
          content: Buffer.from(readmeContent).toString('base64'),
        })
      );
    }

    // Wait for all files to be uploaded
    await Promise.all(fileUploads);

    // Create initial commit message
    const commitMessage = `üéâ Initial commit: AI-generated ${name} project

Generated by Ecosyz AI Code Generator
- Project Type: Web Application  
- Framework: Auto-detected
- Files: ${Object.keys(files).length} generated files
- Date: ${new Date().toISOString()}

This project was created using advanced AI to transform ideas into production-ready code.
`;

    // Update the repository description with additional metadata
    await octokit.rest.repos.update({
      owner: username,
      repo: repoName,
      description: `${description} | AI-generated with Ecosyz`,
      topics: ['ai-generated', 'ecosyz', 'web-app', 'typescript', 'react'],
    });

    const githubUrl = repo.html_url;

    // Log the repository creation
    console.log(`‚úÖ Repository created: ${githubUrl}`);
    console.log(`üìÅ Files uploaded: ${Object.keys(files).length}`);
    console.log(`üë§ Owner: ${username}`);

    return NextResponse.json({
      githubUrl,
      repoName,
      owner: username,
      filesUploaded: Object.keys(files).length,
    });

  } catch (error: any) {
    console.error('GitHub repository creation error:', error);

    // Handle specific GitHub API errors
    if (error.status === 422) {
      return NextResponse.json(
        { error: 'Repository name already exists or is invalid' },
        { status: 400 }
      );
    }

    if (error.status === 401) {
      return NextResponse.json(
        { error: 'Invalid GitHub token. Please reconnect your GitHub account.' },
        { status: 401 }
      );
    }

    if (error.status === 403) {
      return NextResponse.json(
        { error: 'GitHub API rate limit exceeded. Please try again later.' },
        { status: 429 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to create GitHub repository' },
      { status: 500 }
    );
  }
}

// GitHub OAuth connection endpoint
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const code = searchParams.get('code');
    const state = searchParams.get('state');

    if (!code) {
      return NextResponse.json(
        { error: 'Authorization code not provided' },
        { status: 400 }
      );
    }

    // Exchange code for access token
    const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        client_id: process.env.GITHUB_CLIENT_ID,
        client_secret: process.env.GITHUB_CLIENT_SECRET,
        code: code,
      }),
    });

    const tokenData = await tokenResponse.json();

    if (tokenData.error) {
      return NextResponse.json(
        { error: 'Failed to exchange code for token' },
        { status: 400 }
      );
    }

    const accessToken = tokenData.access_token;

    // Get user information
    const octokit = new Octokit({ auth: accessToken });
    const { data: githubUser } = await octokit.rest.users.getAuthenticated();

    // Get authenticated user from Supabase
    const supabase = createClientComponentClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'User not authenticated' },
        { status: 401 }
      );
    }

    // Store GitHub token in user profile
    const { error: updateError } = await supabase
      .from('user_profiles')
      .upsert({
        user_id: user.id,
        github_token: accessToken,
        github_username: githubUser.login,
        github_avatar: githubUser.avatar_url,
        updated_at: new Date().toISOString(),
      });

    if (updateError) {
      console.error('Error updating user profile:', updateError);
      return NextResponse.json(
        { error: 'Failed to save GitHub connection' },
        { status: 500 }
      );
    }

    // Redirect back to the application
    return NextResponse.redirect(new URL('/workspace?github=connected', request.url));

  } catch (error) {
    console.error('GitHub OAuth error:', error);
    return NextResponse.json(
      { error: 'Failed to connect GitHub account' },
      { status: 500 }
    );
  }
}